# For Deb based systems 

The installs themselves are pretty straight forward depending on distro:
The only things to be careful about: Where are you installing your OS and make sure your keyboard input layout is correct (otherwise you won't get past your password aha).

Also make sure that you remove the bootable media after the install and change the boot order so you don't install twice :D

> **_NOTE:_** Use GPT for modern systems, especially if you need support for drives larger than 2TB or UEFI boot.
> However, if your system uses legacy BIOS, MBR may be required.
> For security reasons, many modern Debian-based systems disable the root account by default. I prefer to enable it, but you always have ```sudo``` for elevated tasks.
> I made this guide for beginners to Deb systems (especially with RaspP being so popular and many VPS servers using Deb too) much information might change or is up to personal preferences. 

You can use Rufus or Etcher for quick USBs!

## After initial install

```sudo apt update && sudo apt upgrade -y```

> **_NOTE:_**  While there might be many distros a lot of the kernel uses are similar so I'll try to not be too specific. 
> What is generic is to check your device for what components they have: Especially Graphics devices which often can cause issues. 
> The above can take a few minutes giving you time to do some Google work.

```lspci -nnk ``` 
To see all devices being detected including network, other devices, etc

```lspci | grep -i vga```
For GPU specifically

You can also use ```lscpu``` and ```lsblk```

^ That last one is especially useful for detecting USBs or SSDs, etc

But if you're there already you probably understand CPU architectures :D
If you're unsure again best is to go down some Googling: From you computer's manufacturer website, then check CPU "architecture" or "instruction set"
64 bit, 32 bit, or ARM (Raspberri pi for example) 

This can get confusing because it is sometimes named AMD64 (86x64) because it was created by AMD (then open-sourced, idk?), but doesn't mean it's not compatible with Intel. 
This is also the most adopted now, so most modern hardware will run this.

The same can be done with ```lsusb``` if you're using weird connectors. 

```sudo reboot``` after the update and upgrade are done. 

> **_NOTE:_**
> ````
> lshw      # Hardware configuration
> lsmod     # Loaded kernel modules
> lsscsi    # SCSI devices
> lspnp     # Plug and Play devices
> lsmem     # Memory information
> lstopo    # Hardware topology
> lsattr    # File attributes
> lsof      # List open files
> sudo lshw 


## When first upgrade is done

Now we can take care of graphics: 
For intel it is most of time already integrated... As it's a often used in "dual" graphics 

Then Nvidia:
```sudo apt install {nvidia-driver-XXX}```

For AMD it's a bit more fun: They are included in the Linux kernel due to their open-source. 
But you will need some tools for modern applications:

```sudo apt install mesa-vulkan-drivers mesa-utils``` 

On Linux Mint it is handled automatically, you just have to follow the welcome window launchers green buttons :)

> **_NOTE:_** It's best to go find on the official sites for compatibility:
> Device manufacturer (This gives you the full specs)
> Graphics provider (Specific version compatible with^^)
> You might need libdrm for older hardware

You will need to reboot again, then ```nvidia-smi``` to check or the mesa/vulkan equivalent.

## Keeping an install clean

Keep only essential packages, this both helps your system and makes you less vulnerable:

List all packages: It might seem like there is a lot of fluff depending on distro but if you're on a fresh install it's quite normal as it's all the system components.
This number is still 2-3x lower than a Windows counterpart.

```dpkg -l```

Check an individual problematic package: 

```dpkg -l | grep {package_name}```

Useful to check past pkg installs

```grep "install " /var/log/dpkg.log | tail```

For the lazy people like me (Quoting @Exact-Teacher8489):
You can install with (add sudo):
``` 
apt install $packagename

# But you can also uninstall with:

apt install packagename-

# or

apt remove packagename
```

That first removal method is very neat when using arrow up / down in terminal. 


## Update warnings ‚ö†Ô∏è
These can happen quite frequently when one of the software providers you use didn't update to latest signatures. 
This will give you annoying errors

Here is how to fix it:

Removing
```sudo apt remove --purge {pkgs1} {pkgs2}```

To make sure dependencies are also removed
```sudo apt autoremove --purge```

----

Check the problematic package:

```grep -r {"brave"} /etc/apt/sources.list /etc/apt/sources.list.d/```

Remove it from sources list:

```sudo rm /etc/apt/sources.list.d/{brave-browser-release.list}```

Then run update to your packages lists again to remove the warning:
```sudo apt update```

If you 're still having issues with dependencies USE AT YOUR OWN RISK:

```
sudo apt full-upgrade
sudo apt --fix-broken install
sudo dpkg --configure -a
```

There are also "resolvers" or "managers" that can help you, and it also gives you a visual interface if you don' like the terminal:

``` 
sudo apt install aptitude
# then
aptitude

# or 
sudo apt install synaptic
# then 
synaptic
````

## Security & Privacy üîí


Check security updates are installed: 

```cat /etc/apt/apt.conf.d/20auto-upgrades```

Re-configure it ? 

``` sudo dpkg-reconfigure unattended-upgrades```

----

Firewall

```sudo apt install ufw```
```sudo ufw enable```
```sudo ufw allow ssh``` Make sure to use keys :)

This will restrict incoming traffic, you can use a VPN for further anonimity. 

If you're running local servers: 
```sudo ufw allow 80/tcp``` 

To secure that further you can look into reverse proxies. 

For my browser Mozilla FF is the way to go (they are at much of the origin of documentation about JavaScript as a whole, it is also pre-installed and open-source). If you want to learn more: 
<a href="https://blog.mozilla.org/en/mozilla/introducing-firefox-quantum/" target="_blank">FireFox Quantum Blog Post</a>


You can also add privacy badger and an adblock for an even better experience. I've ditched my TV devices with mini-computers this way!

You can always get Chromium (the same rendering engine, same tools as Chrome without the hassle).

## üñ•Ô∏è Remote desktop sessions

For some weird reason this can be quite annoying depending on the distro

> **_NOTE:_** One thing  I found to fix a lot of my issues is to create a second user with elevated privileges so that you can remote connect to it easily while keeping the device functional on it's own.
> You could also just use VNC but that's cheating and increased latency with framebuffers :D
> You might have to check your session type (Wayland vs x11) but many distros still use x11 by default (on many distros you can simply log out and choose from the login page).
> If you're on nvidia GPU, going the x11 route will have advantages!

```sudo apt install xrdp xserver-xorg-core```

```sudo systemctl enable xrdp```
```sudo systemctl start xrdp```

Check if it's running:

```sudo systemctl status xrdp```

```sudo adduser xrdp ssl-cert```

If not rebooting sometimes helps. 

----

If you have ufw enable make sure to ```sudo ufw allow 3389```
This is the standard port.

If you get a black screen you might need to ```echo "gnome-session" > ~/.xsession```
Depending on your desktop type. 

```ip addr show```

Then add the specific port 3389

It should look something like: 192.x.x.x:3389 and you DO NOT NEED to specify a user just yet.
Now this is where it usually fails because you're already in the session. To me the best is to make a second user for remote sessions:

```sudo adduser {rdpuser}```

Then give it privileges: ```sudo usermod -aG sudo {rdpuser}```

There you go :) You know how to make a good install. For cherry on the cake you can share a folder between all users (this could be your coding or media?)

```chmod 777 {/home/mainuser/shared-folder}```

Then you can login into this new user you created without breaking everything!

## Direct SSH access AND LOW LEVEL X11 ACCESS

One by one: 

``` sudo apt install openssh-server
sudo systemctl start ssh
sudo ufw allow ssh
sudo ufw allow 22
sudo systemctl status ssh
```
Regular SSH access: 

```ssh {user@host}```

Then from your Windows machine: Make sure you installed [ VC](https://vcxsrv.com/)
And launched it.

Check you are using X11 then follow:
```
echo $XDG_SESSION_TYPE
xhost +local:
export DISPLAY={windows_ip:0}
```

If the set up works it's incredibly cool, you can for example:

```
ssh -X user@linux_ip
firefox
```

It will look and feel like a normal window but is running on the linux system! 

![X11DIRECTACCESS](media/capcap.PNG)

It really isn't that complicated but the reason why these are set up like this is to prevent session hijacking: RSA host key fingerprint which is used to verify the server's identity in future connections to prevent man-in-the-middle attacks.

Why you should get a prompt at some point that generates the keys (and asks you to confirm by typing "yes"). 

This also means Native GPU/hardware access without added encoding/decoding. 
What I mean is xrdp is okay, X11 direct is incredible. Then VNC is the noob way. 

This means you can for example get your code editor on your Windows machine but running on the linux system to do whatever you like. 

You can now chose between KDE, XFCE4 or whatver desktop you like... 
I like to keep the original user's desktop intact to always be able to control from there and install desktops on secondary users...

> **_NOTE:_** This is all especially helpful if you're thinking about or have a VPS or any head-less device like a PI.
> You can also use tools like FileZila to monitor system files with a kind of "double tree" interface which uses sFTP
> This let's you for example edit code that is live on a head-less server on the fly using temp downloads.

## Screen tear üì∫ 
Can happen sometimes if you made a mistake in drivers or your install was corrupted.
If you cannot find a solution you can temporarly still get in the app.

Try disabling gpu acceleration for a specific program when launching it through the Terminal: 

```{code} --disable-gpu```


<img src="media/weirdtear.webp" alt="screentearing" width="300">
(Windows example, happens sometimes when launching an app with GPU acceleration on debian systems, likely due to drivers)

If an issue like this persists; I would recommend checking if the installation was not corrupted somewhere along even at initial install..
Simple solution is to check compatibility issues and re-install a clean OS with more knowledge.

It's also recommended to make savepoints before making major changes, there are a lot of different libraries to do this for more redundant storage :D

## Packages
.deb packages are your friends! "dpkg" is designed to work with these files. 
They will be lighter because they interact directly with the host system. 

Flatpack is the most practical way to download apps in my opinion: They will be slightly heavier than on Windows because:
Many modern apps (like Stremio) are built using Electron, which bundles a full Chromium engine and Node.js runtime. This increases the size of the app significantly.

But they install seemlessly with dependencies: 

```flatpak install flathub com.stremio.Stremio```

Some distros like Linux Mint have a neat little software manager pre-installed!
Basically just uses Flatpack for people who don't like terminal. 

For Ubuntu, it will be snap packages by default. But you can easily install flatpack or deb packages too or use other managers. 

Do be careful that .deb interacts with the host system so download from trusted sources. 

## Developer tools

I personally just get vs code from the official source and is nicely integrated with Python with the public Microsoft extensions.
The beauty of it is that a large part of linux itself uses python compatible libraries as it's all open-source. 


You can simply create a file called hello.py and click the python version at the bottom right to start creating a .venv

Then save your code and make sure to run it with the venv path to not get mixed with system wide packages:

```cd .venv```
```./bin/python3 hello.py ```

Neat little extension that automatically selects pasted text (useful for restructuring code quickly).

[DavidpCahill](https://github.com/davidpcahill/auto-select-pasted-text/tree/main)


If you are going to work with PyQt6 and creating GUI you might need some tools:

```
sudo apt install -y libxcb1 libxcb-xinerama0 libxcb-cursor0 libxkbcommon-x11-0 libxcb-render0 libxcb-render-util0

(optional) sudo apt install -y qt6-base-dev qt6-wayland libqt5x11extras5
```
You can also toggle telemetry data off in Visual Studio Code for privacy. 

If you're working with .config, .ignore, files they are always hidden by default and you can see them by doing alt + '.' in your files browser. Or right clicking and enable "Hidden files".

Another thing is on Linux default copy is with shift, it sounds annoying but it's because ctrl + C is reserved for interruption of programs.

---

## System Monitoring üìà

Many know ```htop``` which is great already but there is a special one to my heart because it looks cooler: 

``` sudo apt install btm ```
You can then simply launch it in terminal: ```btm```

If it's not found, it means that you might need to follow install instructions:
Or if you're like me and still confused at the 20 package managers available:
```
curl -LO https://github.com/ClementTsang/bottom/releases/download/0.10.2/bottom_0.10.2-1_amd64.deb
# then 
sudo dpkg -i bottom_0.10.2-1_amd64.deb
```
Want to go deeper ? 
For kernel logs

```` sudo journalctl -k ````

To follow: you will see real-time updates. 

```sudo journalctl -k -f ``` 

What is cool is that you can see how your firewall for example might be protecting you, or even a USB connecting.

## YOUR ENVIRONMENT ! 

Linux is highly customizable in general. 

If you are using default Ubuntu GNOME desktop here is a hot tip:
I hate the fact you have to click 2 times to get to your apps...

```sudo apt install gnome-shell-extensions gnome-shell-extension-manager```

Then toggle ON: Ubuntu Dock

----

[Tasksel](https://wiki.debian.org/tasksel)
package provides a simple interface for users who want to configure their system to perform a specific task. It was recommended by reddit user @Exact-Teacher8489 !

I also loves virtual dektops for managers: in linux MINT its control alt left or right and is super ingrained in my brain. 
You will find yourself using the mouse less which gains you precious time. Up to show global overview of desktops and down to see windows in this desktop.

You can do the same: Ctrl alt shift right/left to move windows to another workspace. You can just alt to return to workspace 1. 

You can also control alt T for a quick terminal & control shift Q to close it. 

There are countless popular managers with varying levels of difficulty, but the original in mint is enough for me:
Right click your menu bar > add workspaces to it, choose how many you want and boom you have virtual desktops.

----

On KDE the default is Meta (windows key) + W to open the overview. 
Here is a link for further set-up as the shortcuts aren't all done by default:
[Ubuntu Forums](https://askubuntu.com/questions/1290451/in-kde-plasma-how-can-i-switch-between-virtual-desktops-using-meta-tab)

----

In PopOS the default will be Ctrl + super + up/down and they also have tiling built-in (automatic resizing) which is very practical. 
When you activated tiling you can also use just super for launcher, and super + direction to select a window.

Then shift + super + up/down to move them to different desktops.

![popostilingworkspaces](media/poposexample.png)

## Reviving Old Hardware @geerlingguy

From what I gather the older the hardware, the more lightweight the distro you will want to pick. 
This means either going the light Ubuntu distros (Mate or Xubuntu) route or Mint which is slightly lighter than Ubuntu.

But if it's not too old you can go for the regular long term support. 
You can also go XFCE route ( another lighter desktop), which might not look as polished but is lighter and has more performance on old hardware. 

There are also a bunch of beautiful systems that are also deb based like Zorin OS and KDE Neon, Pop!OS, Kali, MX and more... But under the hood you will still be able to use all your new knowledge as it's still bellow all the pretty windows.

Deb iso image (that also comes with a desktop) is actually 600mb which is crazy for it can do and all the included tools. So if it's for older hardware just be careful this desktop manager is not too "heavy". 

## üì∑ Working with cameras or HMDI inputs 

Again you might need some basic tools: 
```sudo apt install vlc v4l-utils ffmpeg```

First check devices:
``` ls /dev/video* ```

----
Then check the ouput: 
```ffplay /dev/video0```
Or using VLC (open-source):
```vlc v4l2:///dev/video0```

----

Better yet use open-cv !
``` pip install opencv-python```

Then create a script:
```
import cv2

cap = cv2.VideoCapture(0)
while cap.isOpened():
    _, frame = cap.read()
    _, binary = cv2.threshold(cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY), 127, 255, cv2.THRESH_BINARY)
    cv2.imshow('Binary', binary)
    if cv2.waitKey(1) & 0xFF == ord('q'): break

cap.release()
cv2.destroyAllWindows()
```

You might need to give your user permissions run these seperatly: 
```
sudo usermod -a -G video $USER
newgrp video
```

I've made a guide on how to get old VHS tapes onto hard drives: 
[OBS GUIDE LINUX](https://github.com/h8d13/VHS-To-Digital)

## Working with USBs üîå 

As we mentionned above:

First find detected devices: ```lsusb```

Then we want to understand the devices endpoints IN/OUT, this will print all the verbose info:

```lsusb -d {1c4f:007c} -v```

#### Now that we have the information we need we can try to interface with it, depending on device it might be really easy or the worst time of your life. 

----

``` pip install pyusb```

We'll create a simple keylogger for educational purposes but the idea can be replicated to other more intresting devices (say a fingerpint scanner!) 

```
import usb.core
import usb.util

## QWERTY HEXADECIMAL VALUES
def get_key(data):
   keymap = {
       0x04: 'a', 0x05: 'b', 0x06: 'c', 0x07: 'd', 0x08: 'e', 0x09: 'f',
       0x0A: 'g', 0x0B: 'h', 0x0C: 'i', 0x0D: 'j', 0x0E: 'k', 0x0F: 'l',
       0x10: 'm', 0x11: 'n', 0x12: 'o', 0x13: 'p', 0x14: 'q', 0x15: 'r',
       0x16: 's', 0x17: 't', 0x18: 'u', 0x19: 'v', 0x1A: 'w', 0x1B: 'x',
       0x1C: 'y', 0x1D: 'z', 0x1E: '1', 0x1F: '2', 0x20: '3', 0x21: '4',
       0x22: '5', 0x23: '6', 0x24: '7', 0x25: '8', 0x26: '9', 0x27: '0'
   }
   return keymap.get(data[2], ''), hex(data[2]) if len(data) > 2 else ('', '')

## DETACH FROM KERNEL AND SPECIFY VENDOR+PRODUCT
def monitor_keyboard():
   device = usb.core.find(idVendor=0x1c4f, idProduct=0x007c)
   if device.is_kernel_driver_active(0):
       device.detach_kernel_driver(0)
   
   device.set_configuration()
   endpoint = device.get_active_configuration()[(0,0)][0]

   ### MAIN LOOP RETURN KEY, HEX AND DECIMAL VALUE
   try:
       while True:
           try:
               data = endpoint.read(8)
               key, hex_value = get_key(data)
               if key:
                   print(f"Key: {key} | Hex: {hex_value} | Decimal: {int(hex_value, 16)}")
           except usb.core.USBError as e:
               if e.args[0] != 110:
                   break
   except KeyboardInterrupt:
       device.attach_kernel_driver(0)

if __name__ == "__main__":
   monitor_keyboard()
```

Some devices need specific communications protocols: Say again this was a fingerprint scanner there would often be sent write data that 'activates' the fingerprint area then another to 'confirm'. 

You can often find the information online because some nerd reversed it or it's released by manufacturers. 
when running the verbose command I provided above you will also see entry/exit points of the device which might help üòâ

### BONUS üéÅ

I've included some simple example scripts in the repo for general purposes and reference! 

![SYSTEMONITOR](media/capcapcap.PNG)

One of them is a green dot that is only green if system ressources are healthy.

It's simple but shows off PyQt integration with low level linux system using psutil. 

I made a complete tutorial from Python bindings to C++.

[Modify your system yourself tutorial](https://github.com/h8d13/LSK---Linux-Starter-Kit/tree/main/scripts)

----

### One more bonus...
In a few clicks control other Linux systems (like a phone or tablet with Android) from you new system üòé

```sudo apt install adb scrcpy```

Connect it allow USB debugging (in settings developer mode) & file transfer
‚úÖ Press always allow this computer

Check connections:
``` adb devices```
Then simply run: ```scrcpy``` 

Then you can interface with python this simply opens the clock app:

In your venv terminal:
```pip install pure-python-adb```

Then in python script:
```from ppadb.client import Client as AdbClient

# Connect to ADB
client = AdbClient(host="127.0.0.1", port=5037)
device = client.devices()[0]

# Launch the Samsung Clock app
device.shell("am start -a android.intent.action.MAIN -c android.intent.category.LAUNCHER -n com.sec.android.app.clockpackage/.ClockPackage")
```

You can now play Subway surfers on the side :D Or get neural network to play it for you hehe.

[HayDay Automation Example](https://github.com/h8d13/HayDay)

``` 
from ppadb.client import Client as AdbClient

def swipe_screen(device, x1, y1, x2, y2, duration=2000):
    """
    Simulates a swipe gesture on the connected device.
    :param device: Connected ADB device.

    :param x1: Starting x-coordinate.
    :param y1: Starting y-coordinate.
    :param x2: Ending x-coordinate.
    :param y2: Ending y-coordinate.
    :param duration: ms
    """
    device.shell(f"input swipe {x1} {y1} {x2} {y2} {duration}")
    print(f"Swiped from ({x1}, {y1}) to ({x2}, {y2}) over {duration}ms")

# Connect to ADB and device
client = AdbClient(host="127.0.0.1", port=5037)
devices = client.devices()

if not devices:
    print("No devices connected")
else:
    device = devices[0]
    print(f"Connected to device: {device.serial}")
    swipe_screen(device, 100, 1000, 100, 100, duration=1000)

```
----

You can go a step further to and install F-Droid and Termux on the tablet/phone itself to get a sub linux.

Go to: Settings > Briometrics and Security

Install unknown apps

Go to https://f-droid.org/en/ and download the apk
Then download termux
From F-Droid (Open-source)

Open termux 
Run ```pkg update```
```pkg upgrade```

You can then go full inception and download Python 
``` pkg install python ```

You could even run servers or a lightweight desktop on this hardware too. 
Altho mine is probably too old...

![ANDROID](media/capcapcapcap.PNG)


----

### FINAL BONUS AND I'M OUT
 
After some googling I found out that the GNU project (Stands for GNU Not Unix) a lot of the commands you still use today, file system, bash, gcc, coreutils, POSIX standards, FHS is based/inspired by Unix.
This is ls, cat, rm, cp 

Which linux adds features on top of
An operating system that was dominant in entreprise in the 70-80s and that little hackers like yourself hated because they had to pay AT&T Bell Labs enourmous amounts for licenses. 
Minix was also another "copy" project made for students that was much cheaper alternative 'was about 70$ which you would get a book with :D

Why is this important today? 

Faster development, collaboration, open access to experimentation and iteration, it also makes accountability important as new finds in vulnerabilities or malicious code are resolved quicker. 
It's also freedom of vendor lock-in, both license wise and hardware. Plus the support for modern tech like AI, encryption, etc
Finally, continuity, the fact that these will keep evolving way more than any closed counter-part.

A lot of what I mentionned in this is all available to check out in full because of their open-source nature and that also gives YOU the freedom to do what you want with it today and the next.

Peace <3

You're not done ???? Okay. 

----

```sudo apt install qemu-system-x86 qemu-utils``` to verify install: ```qemu-system-x86_64 --version```

Try QEMU and create your own computer within your computer (used Qubes to make it even more ironic üß†)
Also check compatibility of the OS you're trying to emulate.

```sudo apt install qemu-system-x86 qemu-utils
sudo apt install qemu-kvm libvirt-daemon-system libvirt-clients bridge-utils
```


> **_NOTE:_** You might need to do some extra steps for Virtualization depending on if you're using intel or amd (I mean you're fucked if you have intel?).
> ```LC_ALL=C lscpu | grep Virtualization
> lsmod | grep kvm
> ls -l /dev/kvm
> groups | grep kvm
> sudo usermod -aG kvm $USER
>```


```
qemu-img create -f qcow2 myvm.qcow2 20G

#Create an ISO from a USB or use an existing... There is tools for this too, but since you're a terminal pro.
sudo dd if=/dev/sda of=qubes.iso bs=4M status=progress
## This is also done at a block level copying everything from it including empty space. Now you regret that 512gb USB stick...

## Now you can launch your first VM
qemu-system-x86_64 \
  -enable-kvm \
  -m 2048 \
  -cpu host \
  -smp 2 \
  -hda myvm.qcow2 \
  -cdrom /home/usr/Downloads/qubes.iso \
  -boot d

```

---

When done installing: 
You just need to remove/change some things (the disk and boot order):

```
qemu-system-x86_64 \
  -enable-kvm \
  -m 2048 \
  -cpu host \
  -smp 2 \
  -hda ~/myvm.qcow2 \
  -boot c
```

You might need to play around with settings if you get screen-tear.

> **_NOTE:_**
> For example this fixed my KDE Neon VM. Again depending on what you're trying to achieve and your hardware. Add to the boot commands above:
> Tip: after downloading an ISO rename the annoying name to something shorter. Then right click it properties and it will show the full path to your ISO.
> Also change the 2000 to something higher depending on available RAM, well because 2GiB will not do it for many OSes.
> About the disk space we created I put 20GiB but you might want more for modern OSes. Also what is cool is that this space isn't actually "used" on your host system yet, so unless you clutter the VM it will not take the full size from your host OS.

```
--display gtk,gl=off
```

Make it feel like home: In your QEMU window set the view to "Best Fit" or "Fullscreen" depending on the desktop type try different resolutions: I found to enjoy 16:10 @ 1050px which i think is plenty for dev uness working with HD graphics. 

Ctrl + alt + F to get out of fullscreen. You can also control alt G to lock into the QEMU instance and do the same to release.

----

You're still here.........

Let's 1V1 Rocket League:

Install steam
Go to settings > Compatibilty

Enable proton experimental
RIght click your game go to compatibility again > Force Proton Expiremental. 
This will force some downloads (steam linux run time, proton version, steamworks). 

Otherwise Steam let's you play against bots only, which is a bit sad...

Sometimes it might even re-install the game totally so better to not do that with 130gb game directly. 
You can check proton db for compatibilities. 

For a USB generic xbox controller:

```
sudo apt update
sudo apt install xboxdrv

## If xboxdrv doesn't work, ensure the xpad module is loaded:

sudo modprobe xpad
```

Test your inputs in steam to verify it's all good. 

If still not working it's often the same issue with linux permissions:
```sudo usermod -aG input $USER```

----

"To seek is to recognize potential beyond a current state, a gesture that inherently lacks contempt for what is."
